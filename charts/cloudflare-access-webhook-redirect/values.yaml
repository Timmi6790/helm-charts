# vim: set ft=yaml:
# yaml-language-server: $schema=values.schema.json

# -- Number of replicas to deploy
# Must be at least 1
# @schema
# type: integer
# minimum: 1
# @schema
replicaCount: 1

# @schema
# additionalProperties: true
# @schema
image:
  # -- Container image repository (e.g. docker.io/user/image)
  # @schema
  # type: string
  # @schema
  repository: timmi6790/cloudflare-access-webhook-redirect

  # -- Container image tag (version)
  # @schema
  # type: string
  # @schema
  tag: v0.3.3

  # -- Image pull policy
  # Valid options: Always, IfNotPresent, Never
  # @schema
  # enum: [Always, IfNotPresent, Never]
  # @schema
  pullPolicy: IfNotPresent

# -- Optional image pull secrets for private registries
# @schema
# type: array
# @schema
imagePullSecrets: []

# -- Override the chart name
# @schema
# type: string
# @schema
nameOverride: ""

# -- Override the full release name
# @schema
# type: string
# @schema
fullnameOverride: ""

# @schema
# additionalProperties: true
# @schema
serviceAccount:
  # -- Whether to create a dedicated service account
  # @schema
  # type: boolean
  # @schema
  create: true

  # -- Additional annotations for the service account
  # @schema
  # type: object
  # @schema
  annotations: {}

  # -- Custom service account name (auto-generated if empty)
  # @schema
  # type: string
  # @schema
  name: ""

  # -- Whether to automount the service account token
  # @schema
  # type: boolean
  # @schema
  automountToken: false

# -- Optional Kubernetes PriorityClass name
# @schema
# type: string
# @schema
priorityClassName: ""

# -- Additional annotations for the Pod metadata
# @schema
# type: object
# @schema
podAnnotations: {}

# -- Additional labels for the Pod metadata
# @schema
# type: object
# @schema
podLabels: {}

# @schema
# additionalProperties: true
# @schema
podSecurityContext:
  # -- Run pod as non-root user
  # @schema
  # type: boolean
  # @schema
  runAsNonRoot: true

  # -- User ID to run as
  # @schema
  # type: integer
  # @schema
  runAsUser: 10001

  # -- Group ID for file system access
  # @schema
  # type: integer
  # @schema
  fsGroup: 10001

# @schema
# additionalProperties: true
# @schema
securityContext:
  # -- Allow privilege escalation
  # @schema
  # type: boolean
  # @schema
  allowPrivilegeEscalation: false

  # @schema
  # additionalProperties: true
  # @schema
  capabilities:
    # -- Linux capabilities to drop
    # @schema
    # type: array
    # @schema
    drop:
      - ALL

  # -- Mount root filesystem as read-only
  # @schema
  # type: boolean
  # @schema
  readOnlyRootFilesystem: false

# @schema
# additionalProperties: true
# @schema
application:
  # -- Application log level
  # Options: debug, info, warn, error
  # @schema
  # enum: [debug, info, warn, error]
  # @schema
  logLevel: info

  # -- Sentry DSN for error tracking (empty disables)
  # @schema
  # type: string
  # @schema
  sentryDsn: ""

  # @schema
  # additionalProperties: true
  # @schema
  server:
    # -- HTTP server port
    # @schema
    # type: integer
    # @schema
    port: 8080

    # -- Server bind address
    # @schema
    # type: string
    # @schema
    host: 0.0.0.0

  # @schema
  # additionalProperties: true
  # @schema
  handler:
    # -- Base URL for redirect targets
    # @schema
    # type: string
    # @schema
    targetBase: ""

    # -- Path configurations with allowed HTTP methods
    # Example:
    #   api/webhook:
    #     - ALL
    #   test:
    #     - GET
    #     - POST
    # @schema
    # type: object
    # @schema
    paths: {}

  # @schema
  # additionalProperties: true
  # @schema
  cloudflareAccess:
    # -- Existing secret name containing Cloudflare Access credentials
    # Must contain client_id and client_secret keys
    # @schema
    # type: string
    # @schema
    secretName: ""

    # -- Optional client ID (alternative to secretName)
    # @schema
    # type: [string, "null"]
    # @schema
    # clientId: ""

    # -- Optional client secret (alternative to secretName)
    # @schema
    # type: [string, "null"]
    # @schema
    # clientSecret: ""

# @schema
# additionalProperties: true
# @schema
service:
  # -- Kubernetes service type
  # Options: ClusterIP, NodePort, LoadBalancer
  # @schema
  # enum: [ClusterIP, NodePort, LoadBalancer]
  # @schema
  type: ClusterIP

  # -- Service port
  # @schema
  # type: integer
  # @schema
  port: 80

  # -- Additional service annotations
  # @schema
  # type: object
  # @schema
  annotations: {}

# @schema
# additionalProperties: true
# @schema
ingress:
  # -- Enable ingress resource
  # @schema
  # type: boolean
  # @schema
  enabled: false

  # -- Ingress class name (e.g. nginx)
  # @schema
  # type: string
  # @schema
  ingressClassName: "nginx"

  # -- Additional ingress annotations
  # Example:
  #   cert-manager.io/cluster-issuer: letsencrypt-prod
  #   nginx.ingress.kubernetes.io/rate-limit: "100"
  # @schema
  # type: object
  # @schema
  annotations: {}

  # -- Host definitions for ingress
  # Example:
  #   - host: example.local
  #     paths:
  #       - path: /
  #         pathType: Prefix
  # @schema
  # type: array
  # @schema
  hosts: []

  # -- TLS configuration for ingress
  # Example:
  #   - secretName: example-tls
  #     hosts:
  #       - example.local
  # @schema
  # type: array
  # @schema
  tls: []

# @schema
# additionalProperties: true
# @schema
resources:
  # @schema
  # additionalProperties: true
  # @schema
  limits:
    # -- Maximum CPU usage (e.g. 100m = 0.1 core)
    # @schema
    # type: string
    # @schema
    cpu: 100m

    # -- Maximum memory usage (e.g. 64Mi)
    # @schema
    # type: string
    # @schema
    memory: 15Mi

  # @schema
  # additionalProperties: true
  # @schema
  requests:
    # -- Guaranteed CPU request
    # @schema
    # type: string
    # @schema
    cpu: 10m

    # -- Guaranteed memory request
    # @schema
    # type: string
    # @schema
    memory: 10Mi

# @schema
# additionalProperties: true
# @schema
startupProbe:
  # -- Enable startup probe
  # @schema
  # type: boolean
  # @schema
  enabled: true

  # @schema
  # additionalProperties: true
  # @schema
  httpGet:
    # -- Health check path
    # @schema
    # type: string
    # @schema
    path: /health

    # -- Health check port
    # @schema
    # type: string
    # @schema
    port: http

  # -- Initial delay before probe starts
  # @schema
  # type: integer
  # @schema
  initialDelaySeconds: 0

  # -- Probe frequency
  # @schema
  # type: integer
  # @schema
  periodSeconds: 5

  # -- Probe timeout
  # @schema
  # type: integer
  # @schema
  timeoutSeconds: 3

  # -- Failure threshold
  # @schema
  # type: integer
  # @schema
  failureThreshold: 30

  # -- Success threshold
  # @schema
  # type: integer
  # @schema
  successThreshold: 1

# @schema
# additionalProperties: true
# @schema
livenessProbe:
  # -- Enable liveness probe
  # @schema
  # type: boolean
  # @schema
  enabled: true

  # @schema
  # additionalProperties: true
  # @schema
  httpGet:
    # -- Health check path
    # @schema
    # type: string
    # @schema
    path: /health

    # -- Health check port
    # @schema
    # type: string
    # @schema
    port: http

  # -- Initial delay before probe starts
  # @schema
  # type: integer
  # @schema
  initialDelaySeconds: 10

  # -- Probe frequency
  # @schema
  # type: integer
  # @schema
  periodSeconds: 10

  # -- Probe timeout
  # @schema
  # type: integer
  # @schema
  timeoutSeconds: 5

  # -- Failure threshold
  # @schema
  # type: integer
  # @schema
  failureThreshold: 3

# @schema
# additionalProperties: true
# @schema
readinessProbe:
  # -- Enable readiness probe
  # @schema
  # type: boolean
  # @schema
  enabled: true

  # @schema
  # additionalProperties: true
  # @schema
  httpGet:
    # -- Health check path
    # @schema
    # type: string
    # @schema
    path: /health

    # -- Health check port
    # @schema
    # type: string
    # @schema
    port: http

  # -- Initial delay before probe starts
  # @schema
  # type: integer
  # @schema
  initialDelaySeconds: 5

  # -- Probe frequency
  # @schema
  # type: integer
  # @schema
  periodSeconds: 5

  # -- Probe timeout
  # @schema
  # type: integer
  # @schema
  timeoutSeconds: 3

  # -- Failure threshold
  # @schema
  # type: integer
  # @schema
  failureThreshold: 3

# @schema
# additionalProperties: true
# @schema
autoscaling:
  # -- Enable Horizontal Pod Autoscaler (HPA)
  # @schema
  # type: boolean
  # @schema
  enabled: false

  # -- Minimum replicas
  # @schema
  # type: integer
  # minimum: 1
  # @schema
  minReplicas: 1

  # -- Maximum replicas
  # @schema
  # type: integer
  # minimum: 1
  # @schema
  maxReplicas: 5

  # -- Target CPU utilization (%)
  # @schema
  # type: integer
  # minimum: 1
  # maximum: 100
  # @schema
  targetCPUUtilizationPercentage: 80

  # -- Target memory utilization (%)
  # @schema
  # type: integer
  # minimum: 1
  # maximum: 100
  # @schema
  targetMemoryUtilizationPercentage: 80

# -- Pod topology spread constraints for availability
# @schema
# type: array
# @schema
topologySpreadConstraints: []

# -- Additional volumes (e.g., cache, tmp)
# @schema
# type: array
# @schema
volumes: []

# -- Additional volume mounts (e.g., /cache)
# @schema
# type: array
# @schema
volumeMounts: []

# -- Node selector labels for scheduling
# @schema
# type: object
# @schema
nodeSelector: {}

# -- Tolerations for taints
# @schema
# type: array
# @schema
tolerations: []

# -- Pod affinity rules
# @schema
# type: object
# @schema
affinity: {}

# @schema
# additionalProperties: true
# @schema
podDisruptionBudget:
  # -- Enable PodDisruptionBudget
  # @schema
  # type: boolean
  # @schema
  enabled: false

  # -- Minimum available pods
  # @schema
  # type: [integer, "null"]
  # @schema
  minAvailable: 1

  # -- Maximum unavailable pods
  # @schema
  # type: [integer, "null"]
  # @schema
  maxUnavailable: 1

# @schema
# additionalProperties: true
# @schema
networkPolicy:
  # -- Enable Kubernetes NetworkPolicy
  # @schema
  # type: boolean
  # @schema
  enabled: false

  # -- Policy types (Ingress/Egress)
  # @schema
  # type: array
  # @schema
  policyTypes:
    - Ingress
    - Egress

  # -- Ingress rules
  # @schema
  # type: array
  # @schema
  ingress: []

  # -- Egress rules
  # @schema
  # type: array
  # @schema
  egress: []