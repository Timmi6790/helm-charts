# vim: set ft=yaml:
# yaml-language-server: $schema=values.schema.json

# @schema
# type: integer
# minimum: 1
# @schema
# -- Number of replicas to deploy
replicaCount: 1

# @schema
# additionalProperties: true
# @schema
image:
  # @schema
  # type: string
  # @schema
  # -- Container image repository (e.g. docker.io/user/image)
  repository: timmi6790/cloudflare-access-webhook-redirect

  # @schema
  # type: string
  # @schema
  # -- Container image tag (version)
  tag: v0.3.3

  # @schema
  # enum: [Always, IfNotPresent, Never]
  # @schema
  # -- Image pull policy
  pullPolicy: IfNotPresent

# @schema
# type: array
# @schema
# -- Optional image pull secrets for private registries
imagePullSecrets: []

# @schema
# type: string
# @schema
# -- Override the chart name
nameOverride: ""

# @schema
# type: string
# @schema
# -- Override the full release name
fullnameOverride: ""

# @schema
# additionalProperties: true
# @schema
serviceAccount:
  # @schema
  # type: boolean
  # @schema
  # -- Whether to create a dedicated service account
  create: true

  # @schema
  # type: object
  # @schema
  # -- Additional annotations for the service account
  annotations: {}

  # @schema
  # type: string
  # @schema
  # -- Custom service account name (auto-generated if empty)
  name: ""

  # @schema
  # type: boolean
  # @schema
  # -- Whether to automount the service account token
  automountToken: false

# @schema
# type: string
# @schema
# -- Optional Kubernetes PriorityClass name
priorityClassName: ""

# @schema
# type: object
# @schema
# -- Additional annotations for the Pod metadata
podAnnotations: {}

# @schema
# type: object
# @schema
# -- Additional labels for the Pod metadata
podLabels: {}

# @schema
# additionalProperties: true
# @schema
podSecurityContext:
  # @schema
  # type: boolean
  # @schema
  # -- Run pod as non-root user
  runAsNonRoot: true

  # @schema
  # type: integer
  # @schema
  # -- User ID to run as
  runAsUser: 10001

  # @schema
  # type: integer
  # @schema
  # -- Group ID for file system access
  fsGroup: 10001

# @schema
# additionalProperties: true
# @schema
securityContext:
  # @schema
  # type: boolean
  # @schema
  # -- Allow privilege escalation
  allowPrivilegeEscalation: false

  # @schema
  # additionalProperties: true
  # @schema
  capabilities:
    # @schema
    # type: array
    # @schema
    # -- Linux capabilities to drop
    drop:
      - ALL

  # @schema
  # type: boolean
  # @schema
  # -- Mount root filesystem as read-only
  readOnlyRootFilesystem: false

# @schema
# additionalProperties: true
# @schema
application:
  # @schema
  # enum: [debug, info, warn, error]
  # @schema
  # -- Application log level
  logLevel: info

  # @schema
  # type: string
  # @schema
  # -- Sentry DSN for error tracking (empty disables)
  sentryDsn: ""

  # @schema
  # additionalProperties: true
  # @schema
  server:
    # @schema
    # type: integer
    # @schema
    # -- HTTP server port
    port: 8080

    # @schema
    # type: string
    # @schema
    # -- Server bind address
    host: 0.0.0.0

  # @schema
  # additionalProperties: true
  # @schema
  handler:
    # @schema
    # type: string
    # @schema
    # -- Base URL for redirect targets
    targetBase: ""

    # @schema
    # type: object
    # @schema
    # -- Path configurations with allowed HTTP methods
    # Example:
    #   api/webhook:
    #     - ALL
    #   test:
    #     - GET
    #     - POST
    paths: {}

  # @schema
  # additionalProperties: true
  # @schema
  cloudflareAccess:
    # @schema
    # type: string
    # @schema
    # -- Existing secret name containing Cloudflare Access credentials
    # Must contain client_id and client_secret keys
    secretName: ""

    # @schema
    # type: [string, "null"]
    # @schema
    # -- Optional client ID (alternative to secretName)
    # clientId: ""

    # @schema
    # type: [string, "null"]
    # @schema
    # -- Optional client secret (alternative to secretName)
    # clientSecret: ""

# @schema
# additionalProperties: true
# @schema
service:
  # @schema
  # enum: [ClusterIP, NodePort, LoadBalancer]
  # @schema
  # -- Kubernetes service type
  type: ClusterIP

  # @schema
  # type: integer
  # @schema
  # -- Service port
  port: 80

  # @schema
  # type: object
  # @schema
  # -- Additional service annotations
  annotations: {}

# @schema
# additionalProperties: true
# @schema
ingress:
  # @schema
  # type: boolean
  # @schema
  # -- Enable ingress resource
  enabled: false

  # @schema
  # type: string
  # @schema
  # -- Ingress class name (e.g. nginx)
  ingressClassName: "nginx"

  # @schema
  # type: object
  # @schema
  # -- Additional ingress annotations
  # Example:
  #   cert-manager.io/cluster-issuer: letsencrypt-prod
  #   nginx.ingress.kubernetes.io/rate-limit: "100"
  annotations: {}

  # @schema
  # type: array
  # @schema
  # -- Host definitions for ingress
  # Example:
  #   - host: example.local
  #     paths:
  #       - path: /
  #         pathType: Prefix
  hosts: []

  # @schema
  # type: array
  # @schema
  # -- TLS configuration for ingress
  # Example:
  #   - secretName: example-tls
  #     hosts:
  #       - example.local
  tls: []

# @schema
# additionalProperties: true
# @schema
resources:
  # @schema
  # additionalProperties: true
  # @schema
  limits:
    # @schema
    # type: string
    # @schema
    # -- Maximum CPU usage (e.g. 100m = 0.1 core)
    cpu: 100m

    # @schema
    # type: string
    # @schema
    # -- Maximum memory usage (e.g. 64Mi)
    memory: 15Mi

  # @schema
  # additionalProperties: true
  # @schema
  requests:
    # @schema
    # type: string
    # @schema
    # -- Guaranteed CPU request
    cpu: 10m

    # @schema
    # type: string
    # @schema
    # -- Guaranteed memory request
    memory: 10Mi

# @schema
# additionalProperties: true
# @schema
startupProbe:
  # @schema
  # type: boolean
  # @schema
  # -- Enable startup probe
  enabled: true

  # @schema
  # additionalProperties: true
  # @schema
  httpGet:
    # @schema
    # type: string
    # @schema
    # -- Health check path
    path: /health

    # @schema
    # type: string
    # @schema
    # -- Health check port
    port: http

  # @schema
  # type: integer
  # @schema
  # -- Initial delay before probe starts
  initialDelaySeconds: 0

  # @schema
  # type: integer
  # @schema
  # -- Probe frequency
  periodSeconds: 5

  # @schema
  # type: integer
  # @schema
  # -- Probe timeout
  timeoutSeconds: 3

  # @schema
  # type: integer
  # @schema
  # -- Failure threshold
  failureThreshold: 30

  # @schema
  # type: integer
  # @schema
  # -- Success threshold
  successThreshold: 1

# @schema
# additionalProperties: true
# @schema
livenessProbe:
  # @schema
  # type: boolean
  # @schema
  # -- Enable liveness probe
  enabled: true

  # @schema
  # additionalProperties: true
  # @schema
  httpGet:
    # @schema
    # type: string
    # @schema
    # -- Health check path
    path: /health

    # @schema
    # type: string
    # @schema
    # -- Health check port
    port: http

  # @schema
  # type: integer
  # @schema
  # -- Initial delay before probe starts
  initialDelaySeconds: 10

  # @schema
  # type: integer
  # @schema
  # -- Probe frequency
  periodSeconds: 10

  # @schema
  # type: integer
  # @schema
  # -- Probe timeout
  timeoutSeconds: 5

  # @schema
  # type: integer
  # @schema
  # -- Failure threshold
  failureThreshold: 3

# @schema
# additionalProperties: true
# @schema
readinessProbe:
  # @schema
  # type: boolean
  # @schema
  # -- Enable readiness probe
  enabled: true

  # @schema
  # additionalProperties: true
  # @schema
  httpGet:
    # @schema
    # type: string
    # @schema
    # -- Health check path
    path: /health

    # @schema
    # type: string
    # @schema
    # -- Health check port
    port: http

  # @schema
  # type: integer
  # @schema
  # -- Initial delay before probe starts
  initialDelaySeconds: 5

  # @schema
  # type: integer
  # @schema
  # -- Probe frequency
  periodSeconds: 5

  # @schema
  # type: integer
  # @schema
  # -- Probe timeout
  timeoutSeconds: 3

  # @schema
  # type: integer
  # @schema
  # -- Failure threshold
  failureThreshold: 3

# @schema
# additionalProperties: true
# @schema
autoscaling:
  # @schema
  # type: boolean
  # @schema
  # -- Enable Horizontal Pod Autoscaler (HPA)
  enabled: false

  # @schema
  # type: integer
  # minimum: 1
  # @schema
  # -- Minimum replicas
  minReplicas: 1

  # @schema
  # type: integer
  # minimum: 1
  # @schema
  # -- Maximum replicas
  maxReplicas: 5

  # @schema
  # type: integer
  # minimum: 1
  # maximum: 100
  # @schema
  # -- Target CPU utilization (%)
  targetCPUUtilizationPercentage: 80

  # @schema
  # type: integer
  # minimum: 1
  # maximum: 100
  # @schema
  # -- Target memory utilization (%)
  targetMemoryUtilizationPercentage: 80

# @schema
# type: array
# @schema
# -- Pod topology spread constraints for availability
topologySpreadConstraints: []

# @schema
# type: array
# @schema
# -- Additional volumes (e.g., cache, tmp)
volumes: []

# @schema
# type: array
# @schema
# -- Additional volume mounts (e.g., /cache)
volumeMounts: []

# @schema
# type: object
# @schema
# -- Node selector labels for scheduling
nodeSelector: {}

# @schema
# type: array
# @schema
# -- Tolerations for taints
tolerations: []

# @schema
# type: object
# @schema
# -- Pod affinity rules
affinity: {}

# @schema
# additionalProperties: true
# @schema
podDisruptionBudget:
  # @schema
  # type: boolean
  # @schema
  # -- Enable PodDisruptionBudget
  enabled: false

  # @schema
  # type: [integer, "null"]
  # @schema
  # -- Minimum available pods
  minAvailable: 1

  # @schema
  # type: [integer, "null"]
  # @schema
  # -- Maximum unavailable pods
  maxUnavailable: 1

# @schema
# additionalProperties: true
# @schema
networkPolicy:
  # @schema
  # type: boolean
  # @schema
  # -- Enable Kubernetes NetworkPolicy
  enabled: false

  # @schema
  # type: array
  # @schema
  # -- Policy types (Ingress/Egress)
  policyTypes:
    - Ingress
    - Egress

  # @schema
  # type: array
  # @schema
  # -- Ingress rules
  ingress: []

  # @schema
  # type: array
  # @schema
  # -- Egress rules
  egress: []